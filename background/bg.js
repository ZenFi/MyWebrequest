// Generated by CoffeeScript 1.10.0
(function() {
  var RULES_TYPE, cloneObj, formatHeaders, formatQstr, getQueryString, gsearchRuleBasic, gstaticBasic, logNum, onRequests, pushNotification, requestCache, rules, updateExtIcon;
  gsearchRuleBasic = ['*://www.google.com/url*', '*://www.google.com.hk/url*'];
  gstaticBasic = ['http://ajax.googleapis.com/*', 'http://fonts.googleapis.com/*'];
  RULES_TYPE = ['block', 'hsts', 'log', 'hotlink', 'gsearch', 'gstatic'];
  rules = {
    block: {
      urls: []
    },
    hsts: {
      urls: []
    },
    log: {
      urls: []
    },
    hotlink: {
      urls: []
    },
    gsearch: {
      urls: gsearchRuleBasic
    },
    gstatic: {
      urls: gstaticBasic
    }
  };
  logNum = 0;
  requestCache = {};
  cloneObj = function(o) {
    var i, j, k, key, len, obj, val;
    if (o === null || !(o instanceof Object)) {
      return o;
    }
    if (Array.isArray(o)) {
      if (o.length > 1) {
        obj = [];
        for (k = j = 0, len = o.length; j < len; k = ++j) {
          i = o[k];
          obj[k] = i instanceof Object ? cloneObj(i) : i;
        }
        return obj;
      } else {
        return o[0];
      }
    } else {
      obj = {};
      for (val in o) {
        key = o[val];
        obj[val] = key instanceof Object ? cloneObj(key) : key;
      }
      return obj;
    }
  };
  getQueryString = function(url) {
    /(\?.+)$/.exec(url);
    return RegExp.$1 || '';
  };
  formatQstr = function(url) {
    var arr, e, error, i, j, key, len, pair, qstr, result, val;
    qstr = getQueryString(url);
    qstr = qstr ? qstr.replace(/^\?/, '') : void 0;
    if (!qstr) {
      return false;
    }
    arr = qstr.split('&');
    result = {};
    try {
      for (j = 0, len = arr.length; j < len; j++) {
        i = arr[j];
        pair = i.split('=');
        key = decodeURIComponent(pair[0]);
        val = pair[1] === void 0 ? '' : decodeURIComponent(pair[1]);
        if (result[key] === void 0) {
          result[key] = val;
        } else {
          if (Array.isArray(result[key])) {
            result[key].push(val);
          } else {
            result[key] = [result[key]];
            result[key].push(val);
          }
        }
      }
      return {
        formatedData: result,
        rawData: qstr
      };
    } catch (error) {
      e = error;
      if (e instanceof URIError) {
        result.error = 'The query string is not encoded with utf-8, this can\'t be decoded by now.';
      } else {
        result.error = e.message;
      }
      return result;
    }
  };
  formatHeaders = function(headers) {
    var j, len, obj, val;
    obj = {};
    for (j = 0, len = headers.length; j < len; j++) {
      val = headers[j];
      obj[val.name] = val.value;
    }
    return obj;
  };
  pushNotification = (function() {
    if (chrome.notifications) {
      return function(title, content, notifiId, cb) {
        notifiId = notifiId || '';
        chrome.notifications.create(notifiId, {
          type: 'basic',
          iconUrl: '/img/icon38.png',
          title: title,
          message: content
        }, function() {});
        if (notifiId && cb instanceof Function) {
          chrome.notifications.onClicked.addListener(function(nId) {
            if (nId === notifiId) {
              cb();
            }
          });
        }
      };
    } else if (window.webkitNotifications) {
      return function(title, content) {
        var notifi;
        notifi = webkitNotifications.createNotification('/img/icon48.png', title, content);
        return notifi.show();
      };
    } else {
      return function() {};
    }
  })();
  onRequests = {
    gsearch: {
      fn: function(details) {
        var url;
        url = formatQstr(details.url).formatedData;
        url = url != null ? url.url : void 0;
        if (!url) {
          url = details.url;
        }
        return {
          redirectUrl: url
        };
      },
      permit: ['blocking'],
      on: 'onBeforeRequest'
    },
    block: {
      fn: function(details) {
        return {
          cancel: true
        };
      },
      permit: ['blocking'],
      on: 'onBeforeRequest'
    },
    hsts: {
      fn: function(details) {
        return {
          redirectUrl: details.url.replace(/^http\:\/\//, 'https://')
        };
      },
      permit: ['blocking'],
      on: 'onBeforeRequest'
    },
    hotlink: {
      fn: function(details) {
        var headers, i, j, k, len;
        headers = details.requestHeaders;
        for (k = j = 0, len = headers.length; j < len; k = ++j) {
          i = headers[k];
          if (i.name === 'Referer') {
            headers.splice(k, 1);
            break;
          }
        }
        return {
          requestHeaders: headers
        };
      },
      permit: ['requestHeaders', 'blocking'],
      on: 'onBeforeSendHeaders'
    },
    logBody: {
      fn: function(details) {
        if (details.requestBody) {
          return requestCache[details.requestId] = cloneObj(details.requestBody);
        }
      },
      permit: ['requestBody'],
      on: 'onBeforeRequest'
    },
    logRequest: {
      fn: function(details) {
        var domain, queryBody, rid, url;
        ++logNum;
        url = details.url;
        rid = details.requestId;
        queryBody = formatQstr(details.url);
        domain = /^(?:[\w-]+):\/\/([^\/]+)\//.exec(url);
        domain = domain ? domain[1] : url;
        if (requestCache[rid]) {
          details.requestBody = requestCache[rid];
        }
        details.requestHeaders = formatHeaders(details.requestHeaders);
        if (queryBody) {
          details.queryBody = queryBody;
        }
        console.log('%c%d %o %csent to domain: %s', 'color: #086', logNum, details, 'color: #557c30', domain);
        delete requestCache[rid];
      },
      permit: ['requestHeaders'],
      on: 'onSendHeaders'
    },
    gstatic: {
      fn: function(details) {
        return {
          redirectUrl: details.url.replace('googleapis.com', 'useso.com')
        };
      },
      permit: ['blocking'],
      on: 'onBeforeRequest'
    }
  };
  updateExtIcon = function(iconStyle) {
    if (iconStyle !== 'grey') {
      iconStyle = '';
    }
    if (iconStyle) {
      iconStyle += '-';
    }
    chrome.browserAction.setIcon({
      path: {
        "19": "/img/" + iconStyle + "icon19.png",
        "38": "/img/" + iconStyle + "icon38.png"
      }
    });
  };
  (function() {
    var _rule, j, k, len, onRequest, onoff, reqApi, rule;
    onoff = collection.getLocal('onoff', 'o');
    reqApi = chrome.webRequest;
    onRequest = null;
    for (j = 0, len = RULES_TYPE.length; j < len; j++) {
      k = RULES_TYPE[j];
      if (onoff[k]) {
        _rule = collection.getLocal(k, 'a');
        rule = rules[k];
        if (!(rule.urls.length || _rule.length)) {
          onoff[k] = false;
          continue;
        }
        rule.urls = rule.urls.concat(_rule);
        if (k === 'log') {
          pushNotification(utils.i18n('bg_logison'), utils.i18n('bg_logon_tip'), 'log-enabled-hint', function() {
            window.open('/options/index.html#log');
          });
          onRequest = onRequests['logBody'];
          reqApi[onRequest.on].addListener(onRequest.fn, rule, onRequest.permit);
          onRequest = onRequests['logRequest'];
          reqApi[onRequest.on].addListener(onRequest.fn, rule, onRequest.permit);
        } else {
          onRequest = onRequests[k];
          reqApi[onRequest.on].addListener(onRequest.fn, rule, onRequest.permit);
        }
      } else {
        onoff[k] = false;
      }
    }
    collection.setLocal('onoff', onoff);
    updateExtIcon(collection.getConfig('iconStyle'));
  })();
  window.addEventListener('storage', function(event) {
    var j, k, len, method, newData, oldData, onRequest, reqApi, rule, type;
    type = event.key;
    reqApi = chrome.webRequest;
    newData = JSON.parse(event.newValue || '[]');
    oldData = JSON.parse(event.oldValue || '[]');
    onRequest = null;
    if (type === 'config') {
      if (newData.iconStyle !== oldData.iconStyle) {
        updateExtIcon(newData.iconStyle);
      }
      return;
    }
    if (type === 'onoff') {
      for (j = 0, len = RULES_TYPE.length; j < len; j++) {
        k = RULES_TYPE[j];
        if (newData[k] !== oldData[k]) {
          method = newData[k] ? 'addListener' : 'removeListener';
          rule = rules[k];
          rule.urls = rules[k].urls.concat(collection.getLocal(k, 'a'));
          if (k === 'log') {
            onRequest = onRequests['logBody'];
            reqApi[onRequest.on][method](onRequest.fn, rule, onRequest.permit);
            onRequest = onRequests['logRequest'];
            reqApi[onRequest.on][method](onRequest.fn, rule, onRequest.permit);
          } else {
            onRequest = onRequests[k];
            reqApi[onRequest.on][method](onRequest.fn, rule, onRequest.permit);
          }
        }
      }
      return;
    }
    if (!collection.getSwitch(type)) {
      return;
    }
    rule = rules[type];
    if (Array.isArray(newData)) {
      rule.urls = rule.urls.concat(newData);
    }
    if (type === 'log') {
      reqApi[onRequests['logBody'].on].removeListener(onRequests['logBody'].fn);
      reqApi[onRequests['logRequest'].on].removeListener(onRequests['logRequest'].fn);
    } else {
      onRequest = onRequests[type];
      reqApi[onRequest.on].removeListener(onRequest.fn);
    }
    if (rule.urls.length) {
      setTimeout(function() {
        if (type === 'log') {
          onRequest = onRequests['logBody'];
          reqApi[onRequest.on].addListener(onRequest.fn, rule, onRequest.permit);
          onRequest = onRequests['logRequest'];
          reqApi[onRequest.on].addListener(onRequest.fn, rule, onRequest.permit);
        } else {
          onRequest = onRequests[type];
          reqApi[onRequest.on].addListener(onRequest.fn, rule, onRequest.permit);
        }
      }, 0);
    } else {
      collection.setSwitch(type, false);
    }
  });
})();


//# sourceMappingURL=bg.js.map
